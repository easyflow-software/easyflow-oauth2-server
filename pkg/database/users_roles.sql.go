// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users_roles.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const assignRoleToUser = `-- name: AssignRoleToUser :exec
INSERT INTO users_roles (user_id, role_id) 
VALUES ($1, $2) 
ON CONFLICT DO NOTHING
`

type AssignRoleToUserParams struct {
	UserID uuid.UUID
	RoleID uuid.UUID
}

func (q *Queries) AssignRoleToUser(ctx context.Context, arg AssignRoleToUserParams) error {
	_, err := q.db.ExecContext(ctx, assignRoleToUser, arg.UserID, arg.RoleID)
	return err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.id, r.name, r.description 
FROM roles r
INNER JOIN users_roles ur ON r.id = ur.role_id
WHERE ur.user_id = $1
ORDER BY r.name
`

type GetUserRolesRow struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
}

func (q *Queries) GetUserRoles(ctx context.Context, userID uuid.UUID) ([]GetUserRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserRolesRow
	for rows.Next() {
		var i GetUserRolesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserScopes = `-- name: GetUserScopes :many
SELECT DISTINCT s.name 
FROM scopes s
INNER JOIN roles_scopes rs ON s.id = rs.scope_id
INNER JOIN users_roles ur ON rs.role_id = ur.role_id
WHERE ur.user_id = $1
ORDER BY s.name
`

func (q *Queries) GetUserScopes(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUserScopes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithRole = `-- name: GetUsersWithRole :many
SELECT u.id, u.email, u.first_name, u.last_name 
FROM users u
INNER JOIN users_roles ur ON u.id = ur.user_id
WHERE ur.role_id = $1
ORDER BY u.email
`

type GetUsersWithRoleRow struct {
	ID        uuid.UUID
	Email     string
	FirstName sql.NullString
	LastName  sql.NullString
}

func (q *Queries) GetUsersWithRole(ctx context.Context, roleID uuid.UUID) ([]GetUsersWithRoleRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersWithRole, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersWithRoleRow
	for rows.Next() {
		var i GetUsersWithRoleRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllRolesFromUser = `-- name: RemoveAllRolesFromUser :exec
DELETE FROM users_roles WHERE user_id = $1
`

func (q *Queries) RemoveAllRolesFromUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removeAllRolesFromUser, userID)
	return err
}

const removeRoleFromUser = `-- name: RemoveRoleFromUser :exec
DELETE FROM users_roles 
WHERE user_id = $1 AND role_id = $2
`

type RemoveRoleFromUserParams struct {
	UserID uuid.UUID
	RoleID uuid.UUID
}

func (q *Queries) RemoveRoleFromUser(ctx context.Context, arg RemoveRoleFromUserParams) error {
	_, err := q.db.ExecContext(ctx, removeRoleFromUser, arg.UserID, arg.RoleID)
	return err
}

const userHasRole = `-- name: UserHasRole :one
SELECT EXISTS(SELECT 1 FROM users_roles WHERE user_id = $1 AND role_id = $2)
`

type UserHasRoleParams struct {
	UserID uuid.UUID
	RoleID uuid.UUID
}

func (q *Queries) UserHasRole(ctx context.Context, arg UserHasRoleParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, userHasRole, arg.UserID, arg.RoleID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
