// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: roles_scopes.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const assignScopeToRole = `-- name: AssignScopeToRole :exec
INSERT INTO roles_scopes (role_id, scope_id) 
VALUES ($1, $2) 
ON CONFLICT DO NOTHING
`

type AssignScopeToRoleParams struct {
	RoleID  uuid.UUID
	ScopeID uuid.UUID
}

func (q *Queries) AssignScopeToRole(ctx context.Context, arg AssignScopeToRoleParams) error {
	_, err := q.db.ExecContext(ctx, assignScopeToRole, arg.RoleID, arg.ScopeID)
	return err
}

const getRolesWithScope = `-- name: GetRolesWithScope :many
SELECT r.id, r.name, r.description 
FROM roles r
INNER JOIN roles_scopes rs ON r.id = rs.role_id
WHERE rs.scope_id = $1
ORDER BY r.name
`

type GetRolesWithScopeRow struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
}

func (q *Queries) GetRolesWithScope(ctx context.Context, scopeID uuid.UUID) ([]GetRolesWithScopeRow, error) {
	rows, err := q.db.QueryContext(ctx, getRolesWithScope, scopeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRolesWithScopeRow{}
	for rows.Next() {
		var i GetRolesWithScopeRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScopesForRole = `-- name: GetScopesForRole :many
SELECT s.id, s.name, s.description 
FROM scopes s
INNER JOIN roles_scopes rs ON s.id = rs.scope_id
WHERE rs.role_id = $1
ORDER BY s.name
`

type GetScopesForRoleRow struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
}

func (q *Queries) GetScopesForRole(ctx context.Context, roleID uuid.UUID) ([]GetScopesForRoleRow, error) {
	rows, err := q.db.QueryContext(ctx, getScopesForRole, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetScopesForRoleRow{}
	for rows.Next() {
		var i GetScopesForRoleRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllScopesFromRole = `-- name: RemoveAllScopesFromRole :exec
DELETE FROM roles_scopes WHERE role_id = $1
`

func (q *Queries) RemoveAllScopesFromRole(ctx context.Context, roleID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removeAllScopesFromRole, roleID)
	return err
}

const removeScopeFromRole = `-- name: RemoveScopeFromRole :exec
DELETE FROM roles_scopes 
WHERE role_id = $1 AND scope_id = $2
`

type RemoveScopeFromRoleParams struct {
	RoleID  uuid.UUID
	ScopeID uuid.UUID
}

func (q *Queries) RemoveScopeFromRole(ctx context.Context, arg RemoveScopeFromRoleParams) error {
	_, err := q.db.ExecContext(ctx, removeScopeFromRole, arg.RoleID, arg.ScopeID)
	return err
}

const roleHasScope = `-- name: RoleHasScope :one
SELECT EXISTS(SELECT 1 FROM roles_scopes WHERE role_id = $1 AND scope_id = $2)
`

type RoleHasScopeParams struct {
	RoleID  uuid.UUID
	ScopeID uuid.UUID
}

func (q *Queries) RoleHasScope(ctx context.Context, arg RoleHasScopeParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, roleHasScope, arg.RoleID, arg.ScopeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
